/*
 * SPDX-FileCopyrightText: 2017-2023 Sony Semiconductor Solutions Corporation
 *
 * SPDX-License-Identifier: Apache-2.0
 */
#ifndef SENSCORD_CONNECTION_TCP_CONNECTION_H_
#define SENSCORD_CONNECTION_TCP_CONNECTION_H_

#include <inttypes.h>
#include <string>
#include <map>

#include "senscord/config.h"
#include "senscord/osal.h"
#include "senscord/logger.h"
#include "senscord/connection.h"

namespace senscord {

/**
 * @brief The connection class with TCP Socket.
 */
class TcpConnection : public Connection {
 public:
  /**
   * @brief Open the connection.
   * @param[in] (arguments) connection arguments.
   * @return Status object.
   */
  virtual Status Open(const std::map<std::string, std::string>& arguments);
  virtual Status Open();

  /**
   * @brief Close the connection.
   * @return Status object.
   */
  virtual Status Close();

  /**
   * @brief Connect to the target.
   * @param[in] (param) The informations of the connected target.
   * @return Status object.
   */
  virtual Status Connect(const std::string& param);

  /**
   * @brief Bind as the server.
   * @param[in] (param) The informations of the binding.
   * @return Status object.
   */
  virtual Status Bind(const std::string& param);

  /**
   * @brief Start to listen the connection.
   * @return Status object.
   */
  virtual Status Listen();

  /**
   * @brief Accept the incoming connection.
   * @param[out] (new_connection) The new connection.
   * @param[out] (is_same_system) Whether new connection is on same system.
   * @return Status object.
   */
  virtual Status Accept(Connection** new_connection, bool* is_same_system);

  /**
   * @brief Send the message to the connected target.
   * @param[in] (msg) The semding message.
   * @return Status object.
   */
  virtual Status Send(const Message& msg);

  /**
   * @brief Receive the message from the connected target.
   * @param[out] (msg) The receiving message.
   * @return Status object.
   */
  virtual Status Recv(Message* msg);

  /**
   * @brief Releases message data generated by Recv function.
   * @param[in] (msg_header) Message header.
   * @param[in] (msg_data) Pointer to message data to release.
   * @return Status object.
   */
  virtual Status ReleaseMessage(const MessageHeader& msg_header,
                                void* msg_data) const;

  /**
   * @brief Get raw data for SendFrame of the server.
   * @param[in] (channel) Channel object.
   * @param[out] (rawdata) Information of the raw data to send.
   * @return Status object.
   */
  virtual Status GetChannelRawData(const Channel* channel,
                                   ChannelRawDataInfo* rawdata) const;

  /**
   * @brief Wait to be readable this connection.
   * @param[in] (timeout) Nanoseconds for wating.
   * @return If be readable then return ok.
   */
  virtual Status WaitReadable(uint64_t timeout);

#if 0
  /**
   * @brief Wait to be writable this connection.
   * @param[in] (timeout) Nanoseconds for wating.
   * @return If be writable then return ok.
   */
  virtual Status WaitWritable(uint64_t timeout);
#endif

  /**
   * @brief Set rules for reuse of bind address.
   *
   * When using this function, it must be called before Bind().
   *
   * @param[in] (enable) true: Enable reuse.
   */
  void SetReuseAddr(bool enable);

  /**
   * @brief Constructor.
   */
  TcpConnection();

  /**
   * @brief Constructor with the created socket.
   * @param[in] (socket) The created socket.
   * @param[in] (address) The incoming address.
   * @param[in] (is_same_system) Whether the connection is on same system.
   */
  explicit TcpConnection(
    osal::OSSocket* socket,
    const osal::OSSocketAddressInet& address,
    bool is_same_system);

  /**
   * @brief Destructor.
   */
  ~TcpConnection();

 private:
  /**
   * @bbrief Get the address from parameter.
   * @param[in] (param) The parameter of bind or connect.
   * @return The address for osal socket.
   */
  osal::OSSocketAddressInet GetAddress(const std::string& param) const;

  /**
   * @brief Check whether incoming address is on same system.
   * @param[in] (incoming_address) The incoming address.
   * @return True means the address is on same system.
   */
  bool IsSameSystem(const osal::OSSocketAddressInet& incoming_address) const;

  /**
   * @brief Enable the TCP_NODELAY.
   */
  void EnableNoDelay() const;

  /**
   * @brief Parse arguments.
   */
  void ParseArguments();

 private:
  // tcp socket
  osal::OSSocket* socket_;

  // tcp address for server only
  osal::OSSocketAddressInet address_;

  // flag for reuse of bind address.
  bool reuse_addr_;

  // Whether the accepted client is on the same system.
  bool is_same_system_;

  // Mutex for exclusive sending
  osal::OSMutex* mutex_send_;

  // connect timeout (milliseconds, default=0)
  uint32_t connect_timeout_msec_;
  // receive timeout (milliseconds, default=0)
  uint32_t receive_timeout_msec_;

  // for SocketMessageBuffer
  uint32_t buffer_chunk_size_;
  uint32_t buffer_write_threshold_;

  std::map<std::string, std::string> arguments_;
};

}  // namespace senscord

#endif  // SENSCORD_CONNECTION_TCP_CONNECTION_H_
