/*
 * SPDX-FileCopyrightText: 2017-2023 Sony Semiconductor Solutions Corporation
 *
 * SPDX-License-Identifier: Apache-2.0
 */
#ifndef SENSCORD_CONNECTION_UDS_CONNECTION_H_
#define SENSCORD_CONNECTION_UDS_CONNECTION_H_

#include <stdint.h>
#include <string>
#include <map>

#include "senscord/config.h"
#include "senscord/osal.h"
#include "senscord/connection.h"

namespace senscord {

/**
 * @brief The connection class with Unix domain socket.
 */
class UdsConnection : public Connection {
 public:
  /**
   * @brief Open the connection.
   * @param[in] (arguments) connection arguments.
   * @return Status object.
   */
  virtual Status Open(const std::map<std::string, std::string>& arguments);
  virtual Status Open();

  /**
   * @brief Close the connection.
   * @return Status object.
   */
  virtual Status Close();

  /**
   * @brief Connect to the target.
   * @param[in] (param) The informations of the connected target.
   * @return Status object.
   */
  virtual Status Connect(const std::string& param);

  /**
   * @brief Bind as the server.
   * @param[in] (param) The informations of the binding.
   * @return Status object.
   */
  virtual Status Bind(const std::string& param);

  /**
   * @brief Start to listen the connection.
   * @return Status object.
   */
  virtual Status Listen();

  /**
   * @brief Accept the incoming connection.
   * @param[out] (new_connection) The new connection.
   * @param[out] (is_same_system) Whether new connection is on same system.
   * @return Status object.
   */
  virtual Status Accept(Connection** new_connection, bool* is_same_system);

  /**
   * @brief Send the message to the connected target.
   * @param[in] (msg) The sending message.
   * @return Status object.
   */
  virtual Status Send(const Message& msg);

  /**
   * @brief Receive the message from the connected target.
   * @param[out] (msg) The receiving message.
   * @return Status object.
   */
  virtual Status Recv(Message* msg);

  /**
   * @brief Releases message data generated by Recv function.
   * @param[in] (msg_header) Message header.
   * @param[in] (msg_data) Pointer to message data to release.
   * @return Status object.
   */
  virtual Status ReleaseMessage(const MessageHeader& msg_header,
                                void* msg_data) const;

  /**
   * @brief Get raw data for SendFrame of the server.
   * @param[in] (channel) Channel object.
   * @param[out] (rawdata) Information of the raw data to send.
   * @return Status object.
   */
  virtual Status GetChannelRawData(const Channel* channel,
                                   ChannelRawDataInfo* rawdata) const;

  /**
   * @brief Wait to be readable this connection.
   * @param[in] (timeout) Nanoseconds for waiting.
   * @return If be readable then return ok.
   */
  virtual Status WaitReadable(uint64_t timeout);

  /**
   * @brief Constructor.
   */
  UdsConnection();

  /**
   * @brief Destructor.
   */
  ~UdsConnection();

 private:
  /**
   * @brief Constructor with the created socket.
   * @param[in] (socket) The created socket.
   */
  explicit UdsConnection(int32_t socket);

 private:
  // socket identifier
  int32_t socket_;

  // socket path on the server side
  std::string socket_path_;

  // Mutex for exclusive sending
  osal::OSMutex* mutex_send_;

  // receive timeout (milliseconds, default=0)
  uint32_t receive_timeout_msec_;

  // for SocketMessageBuffer
  uint32_t buffer_chunk_size_;
  uint32_t buffer_write_threshold_;

  std::map<std::string, std::string> arguments_;
};

}  // namespace senscord

#endif  // SENSCORD_CONNECTION_UDS_CONNECTION_H_
