/*
 * SPDX-FileCopyrightText: 2017-2024 Sony Semiconductor Solutions Corporation
 *
 * SPDX-License-Identifier: Apache-2.0
 */
#ifndef SENSCORD_CONNECTION_WS_CONNECTION_H_
#define SENSCORD_CONNECTION_WS_CONNECTION_H_

#include <inttypes.h>
#include <string>
#include <algorithm>
#include <functional>
#include <map>
#include <utility>
#include <vector>
#include "senscord/osal.h"
#include "senscord/osal_inttypes.h"
#include "senscord/logger.h"
#include "senscord/connection.h"
#include "messagepack/web_socket_bridge.h"
#include "websocket/websocket.h"
#include "auto_mutex.h"
#include "../ws_log_macro.h"

namespace senscord {

// WebSocketBridge
static WebSocketBridge ws_bridge_;

/**
 * @brief The Raw data info for Frame Channel.
 */
struct RawDataInfo {
  uint64_t src;      // Raw data pointer
  size_t size;       // Raw data size

  SENSCORD_SERIALIZE_DEFINE(src, size)
};

/**
 * @brief The connection class with Web Socket.
 */
class WsConnection : public Connection {
 public:
  /**
   * @brief Start socket accept control.
   * @return Status object.
   */
  int32_t Start();

  /**
   * @brief Stop to socket accept control.
   * @return Status object.
   */
  int32_t Stop();

  /**
   * @brief The method of the socket accept control thread.
   */
  void Monitoring();

  /**
   * @brief Open the connection.
   * @return Status object.
   */
  virtual Status Open();

  /**
   * @brief Close the connection.
   * @return Status object.
   */
  virtual Status Close();

  /**
   * @brief Bind as the server.
   * @param[in] (param) The informations of the binding.
   * @return Status object.
   */
  virtual Status Bind(const std::string& param);

  /**
   * @brief Start to listen the connection.
   * @return Status object.
   */
  virtual Status Listen();

  /**
   * @brief Accept the incoming connection.
   * @param[out] (new_connection) The new connection.
   * @param[out] (is_same_system) Whether new connection is on same system.
   * @return Status object.
   */
  virtual Status Accept(Connection** new_connection, bool* is_same_system);

  /**
   * @brief Send the message to the connected target.
   * @param[in] (msg) The semding message.
   * @return Status object.
   */
  virtual Status Send(const Message& msg);

  /**
   * @brief Receive the message from the connected target.
   * @param[out] (msg) The receiving message.
   * @return Status object.
   */
  virtual Status Recv(Message* msg);

  /**
   * @brief Releases message data generated by Recv function.
   * @param[in] (msg_header) Message header.
   * @param[in] (msg_data) Pointer to message data to release.
   * @return Status object.
   */
  virtual Status ReleaseMessage(const MessageHeader& msg_header,
                                void* msg_data) const;

  /**
   * @brief Get raw data for SendFrame of the server.
   * @param[in] (channel) Channel object.
   * @param[out] (rawdata) Information of the raw data to send.
   * @return Status object.
   */
  virtual Status GetChannelRawData(const Channel* channel,
                                   ChannelRawDataInfo* rawdata) const;

  /**
   * @brief Wait to be readable this connection.
   * @param[in] (timeout) Nanoseconds for wating.
   * @return If be readable then return ok.
   */
  virtual Status WaitReadable(uint64_t timeout);

  /**
   * @brief Set the primary connection.
   * @param[in] connection  The primary connection.
   */
  void SetPrimary(WsConnection* connection);

  /**
   * @brief Set the secondary connection.
   * @param[in] connection  The secondary connection.
   */
  void SetSecondary(WsConnection* connection);

  /**
   * @brief Constructor.
   */
  WsConnection();

  /**
   * @brief Constructor with the created socket.
   * @param[in] (socket) The created socket.
   * @param[in] (address) The incoming address.
   */
  explicit WsConnection(
    osal::OSSocket* socket,
    const osal::OSSocketAddressInet& address);

  /**
   * @brief Destructor.
   */
  ~WsConnection();

 private:
  /**
   * @bbrief Get the address from parameter.
   * @param[in] (param) The parameter of bind or connect.
   * @return The address for osal socket.
   */
  osal::OSSocketAddressInet GetAddress(const std::string& param) const;

  /**
  * @brief Create palyload length array for web socket frame header.
  * @param[in] (type) frame type.
  * @param[in] (length) frame length.
  * @return length of payload length array.
  */
  size_t CreatePayloadLength(const enum wsFrameType type, const size_t length,
    uint8_t (& outFrame)[10]);

  // tcp socket
  osal::OSSocket* socket_;

  // tcp address for server only
  osal::OSSocketAddressInet address_;

  /**
   * @brief send handshake response.
   * @return Status object.
   */
  Status handshake(void);

  typedef std::vector<senscord::Message *> ReleaseFrameList;

  /**
   * @brief Reserve request of the frame memory for release.
   * @param[in] (header) The message header of communicate between clients/sevrer.
   * @param[in] (frame) Send frame.
   * @return none
   */
  void ReserveReleaseFrame(const MessageHeader& header,
      MessageDataFrameLocalMemory *frame, ReleaseFrameList& release_frame);

  /**
   * @brief Release the Release Frame List.
   * @return none
   */
  void ReleaseReleaseFrameList(ReleaseFrameList& release_frame);

  /**
   * @brief Enqueue the frame memory for release.
   * @return none
   */
  Status EnqReleaseFrame(ReleaseFrameList& release_frame);

  /**
   * @brief read WebSocket message.
   * @param[in] (param) The parameter of payload buffer which loaded.
   * @return Frame type(see enum wsFrameType).
   */
  enum wsFrameType readWsMessage(std::vector<unsigned char>& payload,
      int * length);

  /**
   * @brief Send the message to the connected target witch WebSocket.
   * @param[in] (data) The semding data.
   * @param[in] (len) The semding data length.
   * @return value of the sendmsg.
   */
  int32_t Send(const void* data, size_t len);

  /**
   * @brief Send the encode message to the connected target witch WebSocket.
   * @param[in] (vec) The semding vector data.
   * @param[in] (veclen) The semding vector data length.
   * @return value of the sendmsg.
   */
  int32_t Send(const iovec* vec , size_t veclen);

  /**
   * @brief Send the encode message to the connected target witch WebSocket.
   * @param[in] (data) The semding data.
   * @param[in] (len) The semding data length.
   * @param[in] (frameType) Frame type.
   * @return value of the sendmsg.
   */
  int32_t Send(const void* data, size_t len, enum wsFrameType frameType);

  /**
   * @brief Send the frame event to the connected target.
   * @param[in] (msg) The semding message.
   * @return Status object.
   */
  Status SendEvent(const Message& msg);

  /**
   * @brief Send the frame to the connected target.
   * @param[in] (msg) The semding message.
   * @return Status object.
   */
  Status SendFrame(const Message& msg);

  /**
   * @brief Get Slam Data Format in properties.
   * @param[in] (properties) The properties.
   * @param[out] (format) format string of slam data.
   * @return True means that slam data format found.
   */
  bool GetSlamDataFormat(std::vector<MessageDataProperty>& properties,
      std::string& format);

  /**
   * @brief Get property and set message pack.
   * @param[in] (msg) The sending message.
   * @param[in/out] (vect) Message packed vector.
   * @return none
   */
  void GetPropertyToMsgPack(const Message& msg,
      std::vector<uint8_t> &vect,
      JobMessage jobMessage);

  /**
   * @brief Make a standard reply message.
   * @param[in] (msg) The sending message.
   * @param[in] (job_message) The job message.
   * @param[out] (vect) Message packed vector.
   */
  void MakeStandardReplyMsg(
      const Message& msg, const JobMessage& job_message,
      std::vector<uint8_t>* buffer);

  /**
   * @brief Make a OpenStream reply message.
   * @param[in] (msg) The sending message.
   * @param[in] (job_message) The job message.
   * @param[out] (vect) Message packed vector.
   */
  void MakeOpenStreamReplyMsg(
      const Message& msg,
      const JobMessage& job_message,
      std::vector<uint8_t>* buffer);

  /**
   * @brief Make a GetStreamList reply message.
   * @param[in] (msg) The sending message.
   * @param[in] (job_message) The job message.
   * @param[out] (vect) Message packed vector.
   */
  void MakeGetStreamListReplyMsg(
      const Message& msg,
      const JobMessage& job_message,
      std::vector<uint8_t>* buffer) const;

  /**
   * @brief Make a GetPropertyList reply message.
   * @param[in] (msg) The sending message.
   * @param[in] (job_message) The job message.
   * @param[out] (vect) Message packed vector.
   */
  void MakeGetPropertyListReplyMsg(
      const Message& msg,
      const JobMessage& job_message,
      std::vector<uint8_t>* buffer) const;

  /**
   * @brief Make a GetVersion reply message.
   * @param[in] (msg) The sending message.
   * @param[in] (job_message) The job message.
   * @param[out] (vect) Message packed vector.
   */
  void MakeGetVersionReplyMsg(
      const Message& msg,
      const JobMessage& job_message,
      std::vector<uint8_t>* buffer) const;

  /**
   * @brief Make a LockProperty reply message.
   * @param[in] (msg) The sending message.
   * @param[in] (job_message) The job message.
   * @param[out] (vect) Message packed vector.
   */
  void MakeLockPropertyReplyMsg(
      const Message& msg,
      const JobMessage& job_message,
      std::vector<uint8_t>* buffer) const;

  // Handle and stream_id mappings
  typedef std::map<std::string, OpenStreamInfo> HandleStreamList;
  HandleStreamList handle_stream_;

  // uniq_key and JobMessage mappings
  typedef std::map<uint64_t, JobMessage *> JobList;
  JobList jobs_;

  // request id
  uint64_t request_id_;

  template <typename T>
  void ChannelDataToMsgPack(const RawDataInfo& info,
      std::vector<uint8_t>& raw) {
    std::vector<uint8_t> msg_vect;
    T value = {};
    serialize::Decoder decoder(reinterpret_cast<void*>(info.src), info.size);
    senscord::Status status = decoder.Pop(value);
    SENSCORD_STATUS_TRACE(status);
    SerializeMsg(&value, &msg_vect);
    raw = msg_vect;
  }

  template <typename T>
  void SendConnectedSocket(T& resMsg, const Message& msg) {
    AutoMutex auto_mutex(mutex_handle_);
    // Send a frame to the same stream ID.
    HandleStreamList::const_iterator itr = handle_stream_.begin();
    HandleStreamList::const_iterator end = handle_stream_.end();
    for (; itr != end; itr++) {
      const OpenStreamInfo* info = &itr->second;
      if (info->stream_id == msg.header.server_stream_id) {
        resMsg.handle = itr->first;
        msgpack::vrefbuffer vbuf;
        msgpack::pack(vbuf, resMsg);
        const iovec* vec = vbuf.vector();
        size_t veclen = vbuf.vector_size();
        if (veclen > 0) {
          int32_t ret = Send(vec, veclen);
          if (ret < 0) {
            LOG_E("failed to send: stream id: %" PRIx64,
                msg.header.server_stream_id);
          }
        } else {
          LOG_E("failed to pack");
          break;
        }
      }
    }
  }

  void SetProperties(std::vector<WSF_Channel>& channel_list,
      int channel_num, std::vector<MessageDataProperty>& properties) {
    // For Property
    for (size_t prop = 0; prop < properties.size(); prop++) {
      std::string key = properties[prop].key;
      std::vector<uint8_t> buf;

      Status status = ws_bridge_.BinaryToPropertyPack(key,
          &properties[prop].property.data, &buf);
      if (status.ok()) {
        channel_list[channel_num].map_property[key] = buf;
      } else {
        LOG_D("failed to BinaryToPropertyPack: %s", key.c_str());
      }
    }
  }

  void CreateMutex();
  void DestroyMutex();
  void CommonInit();

  template<typename T, typename U, typename V>
  void insert(osal::OSMutex * m, T& map,  U id, V data) {
    class AutoMutex auto_mutex(m);
    std::pair<U, V> d(id, data);
    map.insert(d);
  }

  osal::OSMutex* mutex_;                // for send
  osal::OSMutex* mutex_job_;            // for command job
  osal::OSMutex* mutex_handle_;         // for stream management handle
  osal::OSMutex* mutex_receive_job_;    // for receive_job

  osal::OSThread* thread_;
  bool end_flag_;
  bool listening_flag_;

  osal::OSCond* cond_receive_job_;
  osal::OSCond* cond_recvive_finish_;
  bool data_available_;

  enum wsState state_;
  struct handshake hs_;
  std::vector<uint8_t> next_packet_;

  enum ReceiveJobType {
    RECEIVE_JOB_SOCKET = 0,
    RECEIVE_JOB_REPLY,
  };
  struct ReceiveJob {
    enum ReceiveJobType type;
    void * address;
  };
  typedef std::vector<struct ReceiveJob> ReceiveJobList;
  ReceiveJobList receive_job_;

  class runOnDestructor {
   public:
    explicit runOnDestructor(std::function<void(void)> func) {
      func_ = func;
    }
    ~runOnDestructor() {
      if (func_ != nullptr) {
        func_();
      }
    }
   private:
    std::function<void(void)> func_;
  };

  int32_t WaitEvent(osal::OSMutex *mutex,
                    osal::OSCond* cond,
                    uint64_t timeout_value) {
    return osal::OSRelativeTimedWaitCond(cond, mutex, timeout_value);
  }

  int32_t SetEvent(osal::OSCond* cond) {
    return osal::OSSignalCond(cond);
  }

  // support secondary
  WsConnection* primary_;
  WsConnection* secondary_;
  osal::OSMutex* mutex_secondary_;
};

}  // namespace senscord

#endif  // SENSCORD_CONNECTION_WS_CONNECTION_H_
